(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/cdk/collections'), require('rxjs'), require('lodash.clonedeep'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('@e-is/ngx-material-table', ['exports', '@angular/core', '@angular/cdk/collections', 'rxjs', 'lodash.clonedeep', 'rxjs/operators'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global['e-is'] = global['e-is'] || {}, global['e-is']['ngx-material-table'] = {}), global.ng.core, global.ng.cdk.collections, global.rxjs, global.cloneDeep, global.rxjs.operators));
}(this, (function (exports, core, collections, rxjs, cloneDeep, operators) { 'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    var cloneDeep__default = /*#__PURE__*/_interopDefaultLegacy(cloneDeep);

    var DefaultValidatorService = /** @class */ (function () {
        function DefaultValidatorService() {
        }
        DefaultValidatorService.prototype.getRowValidator = function () {
            return null;
        };
        return DefaultValidatorService;
    }());
    DefaultValidatorService.decorators = [
        { type: core.Injectable }
    ];

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    ;
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var TableElement = /** @class */ (function () {
        function TableElement() {
        }
        TableElement.prototype.delete = function () {
            this.source.delete(this.id);
        };
        TableElement.prototype.confirmEditCreate = function () {
            if (this.id === -1) {
                return this.source.confirmCreate(this);
            }
            else {
                return this.source.confirmEdit(this);
            }
        };
        TableElement.prototype.startEdit = function () {
            this.originalData = cloneDeep__default['default'](this.currentData);
            this.editing = true;
        };
        TableElement.prototype.cancelOrDelete = function () {
            if (this.id == -1 || !this.editing)
                this.delete();
            else {
                this.currentData = this.originalData;
                this.editing = false;
            }
        };
        return TableElement;
    }());

    var TableElementReactiveForms = /** @class */ (function (_super) {
        __extends(TableElementReactiveForms, _super);
        function TableElementReactiveForms(init) {
            var _this = _super.call(this) || this;
            _this.validator = init.validator;
            Object.assign(_this, init);
            return _this;
        }
        Object.defineProperty(TableElementReactiveForms.prototype, "currentData", {
            get: function () {
                return this.validator.getRawValue();
            },
            set: function (data) {
                this.validator.patchValue(data);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TableElementReactiveForms.prototype, "editing", {
            get: function () {
                return this.validator.enabled;
            },
            set: function (value) {
                if (value) {
                    this.validator.enable();
                }
                else {
                    this.validator.disable();
                }
            },
            enumerable: false,
            configurable: true
        });
        TableElementReactiveForms.prototype.isValid = function () {
            return this.validator.valid;
        };
        return TableElementReactiveForms;
    }(TableElement));

    var TableElementTemplateDriven = /** @class */ (function (_super) {
        __extends(TableElementTemplateDriven, _super);
        function TableElementTemplateDriven(init) {
            var _this = _super.call(this) || this;
            Object.assign(_this, init);
            return _this;
        }
        Object.defineProperty(TableElementTemplateDriven.prototype, "validator", {
            get: function () {
                return null;
            },
            set: function (value) { },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TableElementTemplateDriven.prototype, "currentData", {
            get: function () {
                return this._currentData;
            },
            set: function (data) {
                this._currentData = data;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TableElementTemplateDriven.prototype, "editing", {
            get: function () {
                return this._editing;
            },
            set: function (value) {
                this._editing = value;
            },
            enumerable: false,
            configurable: true
        });
        TableElementTemplateDriven.prototype.isValid = function () {
            return true;
        };
        return TableElementTemplateDriven;
    }(TableElement));

    var TableElementFactory = /** @class */ (function () {
        function TableElementFactory() {
        }
        TableElementFactory.createTableElement = function (newElement) {
            if (this.isValidatorDefined(newElement)) {
                // Create reactive forms element here.
                return new TableElementReactiveForms(newElement);
            }
            else {
                // Default is the one without validator.
                return new TableElementTemplateDriven(newElement);
            }
        };
        TableElementFactory.isValidatorDefined = function (newElement) {
            return newElement.validator != null && newElement.validator != undefined;
        };
        return TableElementFactory;
    }());

    var TableDataSource = /** @class */ (function (_super) {
        __extends(TableDataSource, _super);
        /**
         * Creates a new TableDataSource instance, that can be used as datasource of `@angular/cdk` data-table.
         * @param data Array containing the initial values for the TableDataSource. If not specified, then `dataType` must be specified.
         * @param dataType Type of data contained by the Table. If not specified, then `data` with at least one element must be specified.
         * @param validatorService Service that create instances of the FormGroup used to validate row fields.
         * @param config Additional configuration for table.
         */
        function TableDataSource(data, dataType, validatorService, config) {
            if (config === void 0) { config = { prependNewElements: false, suppressErrors: false }; }
            var _this = _super.call(this) || this;
            _this.validatorService = validatorService;
            _this.config = config;
            _this.connectedViewers = [];
            if (!validatorService) {
                _this.validatorService = new DefaultValidatorService();
            }
            if (dataType) {
                _this.dataConstructor = dataType;
            }
            else {
                if (data && data.length > 0) {
                    _this.dataKeys = Object.keys(data[0]);
                }
                else {
                    throw new Error('You must define either a non empty array, or an associated class to build the table.');
                }
            }
            _this.checkValidatorFields(_this.validatorService);
            _this.rowsSubject = new rxjs.BehaviorSubject(_this.getRowsFromData(data));
            _this.datasourceSubject = new rxjs.Subject();
            return _this;
        }
        TableDataSource.prototype.checkValidatorFields = function (validatorService) {
            if (!this.config.suppressErrors)
                return; // Skip, as error will not be logged
            var formGroup = validatorService.getRowValidator();
            if (formGroup != null) {
                var rowKeys_1 = Object.keys(this.createNewObject());
                var invalidKeys = Object.keys(formGroup.controls).filter(function (key) { return !rowKeys_1.some(function (x) { return x === key; }); });
                if (invalidKeys.length > 0) {
                    this.logError('Validator form control keys must match row object keys. Invalid keys: ' + invalidKeys.toString());
                }
            }
        };
        TableDataSource.prototype.logError = function (message) {
            if (!this.config.suppressErrors)
                console.error(message);
        };
        /**
         * Start the creation of a new element, pushing an empty-data row in the table.
         */
        TableDataSource.prototype.createNew = function () {
            var source = this.rowsSubject.getValue();
            if (!this.existsNewElement(source)) {
                var newElement = TableElementFactory.createTableElement({
                    id: -1,
                    editing: true,
                    currentData: this.createNewObject(),
                    source: this,
                    validator: this.validatorService.getRowValidator(),
                });
                if (this.config.prependNewElements) {
                    this.rowsSubject.next([newElement].concat(source));
                }
                else {
                    source.push(newElement);
                    this.rowsSubject.next(source);
                }
            }
        };
        /**
         * Confirm creation of the row. Save changes and disable editing.
         * If validation active and row data is invalid, it doesn't confirm creation neither disable editing.
         * @param row Row to be confirmed.
         */
        TableDataSource.prototype.confirmCreate = function (row) {
            if (!row.isValid()) {
                return false;
            }
            var source = this.rowsSubject.getValue();
            row.id = source.length - 1;
            this.rowsSubject.next(source);
            row.editing = false;
            this.updateDatasourceFromRows(source);
            return true;
        };
        /**
         * Confirm edition of the row. Save changes and disable editing.
         * If validation active and row data is invalid, it doesn't confirm editing neither disable editing.
         * @param row Row to be edited.
         */
        TableDataSource.prototype.confirmEdit = function (row) {
            if (!row.isValid()) {
                return false;
            }
            var source = this.rowsSubject.getValue();
            var index = this.getIndexFromRowId(row.id, source);
            source[index] = row;
            this.rowsSubject.next(source);
            row.originalData = undefined;
            row.editing = false;
            this.updateDatasourceFromRows(source);
            return true;
        };
        /**
         * Delete the row with the index specified.
         */
        TableDataSource.prototype.delete = function (id) {
            var source = this.rowsSubject.getValue();
            var index = this.getIndexFromRowId(id, source);
            source.splice(index, 1);
            this.updateRowIds(index, source);
            this.rowsSubject.next(source);
            if (id != -1)
                this.updateDatasourceFromRows(source);
        };
        /**
       * Get row from the table.
       * @param id Id of the row to retrieve, -1 returns the current new line.
       */
        TableDataSource.prototype.getRow = function (id) {
            var source = this.rowsSubject.getValue();
            var index = this.getIndexFromRowId(id, source);
            return (index >= 0 && index < source.length) ? source[index] : null;
        };
        /**
         * Update the datasource with a new array of data. If the array reference
         * is the same as the previous one, it doesn't trigger an update.
         * @param data Data to update the table datasource.
         * @param options Specify options to update the datasource.
         * If emitEvent is true and the datasource is updated, it emits an event
         * from 'datasourceSubject' with the updated data. If false, it doesn't
         * emit an event. True by default.
         */
        TableDataSource.prototype.updateDatasource = function (data, options) {
            if (options === void 0) { options = { emitEvent: true }; }
            if (this.currentData !== data) {
                this.currentData = data;
                this.rowsSubject.next(this.getRowsFromData(data));
                if (options.emitEvent)
                    this.datasourceSubject.next(data);
            }
        };
        /**
         * Checks the existance of the a new row (not yet saved).
         * @param source
         */
        TableDataSource.prototype.existsNewElement = function (source) {
            return !(source.length == 0 || source[this.getNewRowIndex(source)].id > -1);
        };
        /**
         * Returns the possible index of the new row depending on the insertion type.
         * It doesn't imply that the new row is created, that must be checked.
         * @param source
         */
        TableDataSource.prototype.getNewRowIndex = function (source) {
            if (this.config.prependNewElements)
                return 0;
            else
                return source.length - 1;
        };
        /**
         * Returns the row id from the index specified. It does
         * not consider if the new row is present or not, assumes
         * that new row is not present.
         * @param index Index of the array.
         * @param count Quantity of elements in the array.
         */
        TableDataSource.prototype.getRowIdFromIndex = function (index, count) {
            if (this.config.prependNewElements)
                return count - 1 - index;
            else
                return index;
        };
        /**
         * Returns the index from the row id specified.
         * It takes into account if the new row exists or not.
         * @param id
         * @param source
         */
        TableDataSource.prototype.getIndexFromRowId = function (id, source) {
            if (id == -1) {
                return this.existsNewElement(source) ? this.getNewRowIndex(source) : -1;
            }
            else {
                if (this.config.prependNewElements)
                    return source.length - 1 - id;
                else
                    return id;
            }
        };
        /**
         * Update rows ids in the array specified, starting in the specified index
         * until the start/end of the array, depending on config.prependNewElements
         * configuration.
         * @param initialIndex Initial index of source to be updated.
         * @param source Array that contains the rows to be updated.
         */
        TableDataSource.prototype.updateRowIds = function (initialIndex, source) {
            var delta = this.config.prependNewElements ? -1 : 1;
            for (var index = initialIndex; index < source.length && index >= 0; index += delta) {
                if (source[index].id != -1)
                    source[index].id = this.getRowIdFromIndex(index, source.length);
            }
        };
        /**
         * Get the data from the rows.
         * @param rows Rows to extract the data.
         */
        TableDataSource.prototype.getDataFromRows = function (rows) {
            return rows
                .filter(function (row) { return row.id != -1; })
                .map(function (row) {
                return row.originalData ? row.originalData : row.currentData;
            });
        };
        /**
         * Update the datasource with the data contained in the specified rows.
         * @param rows Rows that contains the datasource's new data.
         */
        TableDataSource.prototype.updateDatasourceFromRows = function (rows) {
            this.currentData = this.getDataFromRows(rows);
            this.datasourceSubject.next(this.currentData);
        };
        /**
         * From an array of data, it returns rows containing the original data.
         * @param arrayData Data from which create the rows.
         */
        TableDataSource.prototype.getRowsFromData = function (arrayData) {
            var _this = this;
            return arrayData.map(function (data, index) {
                return TableElementFactory.createTableElement({
                    id: _this.getRowIdFromIndex(index, arrayData.length),
                    editing: false,
                    currentData: data,
                    source: _this,
                    validator: _this.validatorService.getRowValidator(),
                });
            });
        };
        /**
         * Create a new object with identical structure than the table source data.
         * It uses the object's type contructor if available, otherwise it creates
         * an object with the same keys of the first element contained in the original
         * datasource (used in the constructor).
         */
        TableDataSource.prototype.createNewObject = function () {
            if (this.dataConstructor) {
                return new this.dataConstructor();
            }
            else {
                return this.dataKeys.reduce(function (obj, key) {
                    obj[key] = undefined;
                    return obj;
                }, {});
            }
        };
        /** Connect function called by the table to retrieve one stream containing
         *  the data to render. */
        /*connect(): Observable<TableElement<T>[]> {
          return this.rowsSubject.asObservable();
        }*/
        TableDataSource.prototype.connect = function (collectionViewer) {
            var range = {
                start: 0,
                end: -1
            };
            if (collectionViewer) {
                this.connectedViewers.push({
                    viewer: collectionViewer,
                    range: range,
                    subscription: collectionViewer.viewChange.subscribe(function (r) {
                        range.start = r.start;
                        range.end = r.end;
                    })
                });
            }
            return this.rowsSubject.asObservable()
                .pipe(operators.map(function (data) {
                if (range.start > 0) {
                    if (range.end > range.start) {
                        return data.slice(range.start, range.end);
                    }
                    return data.slice(range.start);
                }
                return data;
            }));
        };
        TableDataSource.prototype.disconnect = function (collectionViewer) {
            var ref = this.connectedViewers.find(function (ref) { return ref.viewer === collectionViewer; });
            if (ref && ref.subscription) {
                ref.subscription.unsubscribe();
            }
        };
        return TableDataSource;
    }(collections.DataSource));

    var ValidatorService = /** @class */ (function () {
        function ValidatorService() {
        }
        return ValidatorService;
    }());
    ValidatorService.decorators = [
        { type: core.Injectable }
    ];

    /**
     * Generated bundle index. Do not edit.
     */

    exports.DefaultValidatorService = DefaultValidatorService;
    exports.TableDataSource = TableDataSource;
    exports.TableElement = TableElement;
    exports.TableElementFactory = TableElementFactory;
    exports.TableElementReactiveForms = TableElementReactiveForms;
    exports.TableElementTemplateDriven = TableElementTemplateDriven;
    exports.ValidatorService = ValidatorService;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=e-is-ngx-material-table.umd.js.map
