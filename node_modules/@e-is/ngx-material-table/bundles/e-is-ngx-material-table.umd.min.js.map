{"version":3,"sources":["../esm2015/src/src/app/ngx-material-table/default-validator.service.ts","../../node_modules/tslib/tslib.es6.js","../esm2015/src/src/app/ngx-material-table/table-element.ts","../esm2015/src/src/app/ngx-material-table/table-element-reactive-forms.ts","../esm2015/src/src/app/ngx-material-table/table-element-template-driven.ts","../esm2015/src/src/app/ngx-material-table/table-element.factory.ts","../esm2015/src/src/app/ngx-material-table/table-data-source.ts","../esm2015/src/src/app/ngx-material-table/validator.service.ts"],"names":["DefaultValidatorService","prototype","getRowValidator","Injectable","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","call","__extends","__","this","constructor","create","TableElement","delete","source","id","confirmEditCreate","confirmCreate","confirmEdit","startEdit","originalData","cloneDeep","currentData","editing","cancelOrDelete","TableElementReactiveForms","init","_this","_super","validator","assign","defineProperty","getRawValue","data","patchValue","enabled","value","enable","disable","isValid","valid","TableElementTemplateDriven","_currentData","_editing","TableElementFactory","createTableElement","newElement","isValidatorDefined","undefined","TableDataSource","dataType","validatorService","config","prependNewElements","suppressErrors","connectedViewers","dataConstructor","length","Error","dataKeys","keys","checkValidatorFields","rowsSubject","BehaviorSubject","getRowsFromData","datasourceSubject","Subject","formGroup","rowKeys_1","createNewObject","invalidKeys","controls","filter","key","some","x","logError","toString","message","console","error","createNew","getValue","existsNewElement","next","concat","push","row","updateDatasourceFromRows","getIndexFromRowId","index","splice","updateRowIds","getRow","updateDatasource","options","emitEvent","getNewRowIndex","getRowIdFromIndex","count","initialIndex","delta","getDataFromRows","rows","map","arrayData","reduce","obj","connect","collectionViewer","range","start","end","viewer","subscription","viewChange","subscribe","r","asObservable","pipe","slice","disconnect","ref","find","unsubscribe","DataSource"],"mappings":"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","sourcesContent":["import { Injectable } from '@angular/core';\nimport { FormGroup } from '@angular/forms';\n\nimport { ValidatorService } from './validator.service';\n\n@Injectable()\nexport class DefaultValidatorService implements ValidatorService {\n\n  getRowValidator(): FormGroup {\n    return null;\n  }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { FormGroup } from '@angular/forms';\nimport cloneDeep from 'lodash.clonedeep';\n\nimport { TableDataSource } from './table-data-source';\n\nexport abstract class TableElement<T> {\n  id: number;\n  originalData?: T;\n  source: TableDataSource<T>;\n\n  abstract get editing(): boolean;\n  abstract set editing(editing: boolean);\n  abstract get currentData(): T;\n  abstract set currentData(currentData: T);\n  abstract get validator(): FormGroup;\n  abstract set validator(validator: FormGroup);\n\n  delete(): void {\n    this.source.delete(this.id);\n  }\n\n  confirmEditCreate(): boolean {\n    if (this.id === -1) {\n      return this.source.confirmCreate(this);\n    }\n    else {\n      return this.source.confirmEdit(this);\n    }\n  }\n\n  startEdit(): void {\n    this.originalData = cloneDeep(this.currentData);\n    this.editing = true;\n  }\n\n  cancelOrDelete() {\n    if (this.id == -1 || !this.editing)\n      this.delete();\n    else {\n      this.currentData = this.originalData;\n      this.editing = false;\n    }\n  }\n\n  abstract isValid(): boolean;\n}\n","import { TableElement } from './table-element';\nimport { FormGroup } from '@angular/forms';\n\nimport { TableDataSource } from './table-data-source';\n\nexport class TableElementReactiveForms<T> extends TableElement<T> {\n  id: number;\n  originalData?: T;\n  source: TableDataSource<T>;\n  validator: FormGroup;\n\n  get currentData(): T {\n    return this.validator.getRawValue();\n  }\n\n  set currentData(data :T) {\n    this.validator.patchValue(data);\n  }\n\n  get editing(): boolean {\n    return this.validator.enabled;\n  }\n\n  set editing(value :boolean) {\n    if(value) {\n      this.validator.enable();\n    } else {\n      this.validator.disable();\n    }\n  }\n\n  constructor(init: Partial<TableElementReactiveForms<T>>) {\n    super();\n    this.validator = init.validator;\n    Object.assign(this, init);\n  }\n\n  isValid() {\n    return this.validator.valid;\n  }\n}\n","import { FormGroup } from '@angular/forms';\n\nimport { TableDataSource } from './table-data-source';\n\nimport { TableElement } from './table-element';\n\nexport class TableElementTemplateDriven<T> extends TableElement<T> {\n  id: number;\n  _editing: boolean;\n  _currentData: T;\n  originalData?: T;\n  source: TableDataSource<T>;\n\n  get validator(): any {\n    return null;\n  }\n\n  set validator(value: any) { }\n\n  get currentData(): T {\n    return this._currentData;\n  }\n\n  set currentData(data :T) {\n    this._currentData = data;\n  }\n\n  get editing(): boolean {\n    return this._editing;\n  }\n\n  set editing(value :boolean) {\n    this._editing = value;\n  }\n\n  constructor(init: Partial<TableElementTemplateDriven<T>>) {\n    super();\n    Object.assign(this, init);\n  }\n\n  isValid() {\n    return true;\n  }\n}\n","import { TableElementReactiveForms } from './table-element-reactive-forms';\nimport { TableElementTemplateDriven } from './table-element-template-driven';\n\nexport class TableElementFactory {\n\n  public static createTableElement(newElement: any): any {\n    if (this.isValidatorDefined(newElement)) {\n      // Create reactive forms element here.\n      return new TableElementReactiveForms(newElement);\n    } else {\n      // Default is the one without validator.\n      return new TableElementTemplateDriven(newElement);\n    }\n  }\n\n  static isValidatorDefined(newElement: any) {\n    return newElement.validator != null && newElement.validator != undefined; \n  }\n}","import {CollectionViewer, DataSource, ListRange} from '@angular/cdk/collections';\n\nimport {BehaviorSubject, Observable, Subject, Subscribable, Subscription} from 'rxjs';\n\nimport { TableElementFactory } from './table-element.factory';\nimport { ValidatorService } from './validator.service';\nimport { TableElement } from './table-element';\nimport { DefaultValidatorService } from './default-validator.service';\nimport {map} from 'rxjs/operators';\n\nexport class TableDataSource<T> extends DataSource<TableElement<T>> {\n\n  protected rowsSubject: BehaviorSubject<TableElement<T>[]>;\n  datasourceSubject: Subject<T[]>;\n\n  protected dataConstructor: new () => T;\n  protected dataKeys: any[];\n  protected connectedViewers: {\n    viewer: CollectionViewer;\n    subscription: Subscription;\n    range: ListRange;\n  }[] = [];\n\n  protected currentData: any;\n\n  /**\n   * Creates a new TableDataSource instance, that can be used as datasource of `@angular/cdk` data-table.\n   * @param data Array containing the initial values for the TableDataSource. If not specified, then `dataType` must be specified.\n   * @param dataType Type of data contained by the Table. If not specified, then `data` with at least one element must be specified.\n   * @param validatorService Service that create instances of the FormGroup used to validate row fields.\n   * @param config Additional configuration for table.\n   */\n  constructor(\n    data: T[],\n    dataType?: new () => T,\n    private validatorService?: ValidatorService,\n    private config = { prependNewElements: false, suppressErrors: false }) {\n    super();\n\n    if (!validatorService) {\n      this.validatorService = new DefaultValidatorService();\n    }\n\n    if (dataType) {\n      this.dataConstructor = dataType;\n    } else {\n      if (data && data.length > 0) {\n        this.dataKeys = Object.keys(data[0]);\n      } else {\n        throw new Error('You must define either a non empty array, or an associated class to build the table.');\n      }\n    }\n\n    this.checkValidatorFields(this.validatorService);\n\n    this.rowsSubject = new BehaviorSubject(this.getRowsFromData(data));\n    this.datasourceSubject = new Subject<T[]>();\n  }\n\n  protected checkValidatorFields(validatorService: ValidatorService) {\n    if (!this.config.suppressErrors) return; // Skip, as error will not be logged\n    const formGroup = validatorService.getRowValidator();\n    if(formGroup != null) {\n      const rowKeys = Object.keys(this.createNewObject());\n      const invalidKeys = Object.keys(formGroup.controls).filter(key => !rowKeys.some(x => x === key));\n      if (invalidKeys.length > 0) {\n        this.logError('Validator form control keys must match row object keys. Invalid keys: ' + invalidKeys.toString());\n      }\n    }\n  }\n\n  protected logError(message: string) {\n    if(!this.config.suppressErrors)\n      console.error(message);\n  }\n\n  /**\n   * Start the creation of a new element, pushing an empty-data row in the table.\n   */\n  createNew(): void {\n    const source = this.rowsSubject.getValue();\n\n    if (!this.existsNewElement(source)) {\n\n      const newElement = TableElementFactory.createTableElement({\n        id: -1,\n        editing: true,\n        currentData: this.createNewObject(),\n        source: this,\n        validator: this.validatorService.getRowValidator(),\n      });\n\n      if (this.config.prependNewElements) {\n        this.rowsSubject.next([newElement].concat(source));\n      } else {\n        source.push(newElement);\n        this.rowsSubject.next(source);\n      }\n    }\n  }\n\n  /**\n   * Confirm creation of the row. Save changes and disable editing.\n   * If validation active and row data is invalid, it doesn't confirm creation neither disable editing.\n   * @param row Row to be confirmed.\n   */\n  confirmCreate(row: TableElement<T>): boolean {\n    if (!row.isValid()) {\n      return false\n    }\n\n    const source = this.rowsSubject.getValue();\n    row.id = source.length - 1;\n    this.rowsSubject.next(source);\n\n    row.editing = false;\n\n    this.updateDatasourceFromRows(source);\n    return true;\n  }\n\n  /**\n   * Confirm edition of the row. Save changes and disable editing.\n   * If validation active and row data is invalid, it doesn't confirm editing neither disable editing.\n   * @param row Row to be edited.\n   */\n  confirmEdit(row: TableElement<T>): boolean {\n    if (!row.isValid()) {\n      return false;\n    }\n\n    const source = this.rowsSubject.getValue();\n    const index = this.getIndexFromRowId(row.id, source);\n\n    source[index] = row;\n    this.rowsSubject.next(source);\n\n    row.originalData = undefined;\n    row.editing = false;\n\n    this.updateDatasourceFromRows(source);\n    return true;\n  }\n\n  /**\n   * Delete the row with the index specified.\n   */\n  delete(id: number): void {\n    const source = this.rowsSubject.getValue();\n    const index = this.getIndexFromRowId(id, source);\n\n    source.splice(index, 1);\n    this.updateRowIds(index, source);\n\n    this.rowsSubject.next(source);\n\n    if (id != -1)\n      this.updateDatasourceFromRows(source);\n  }\n\n  /**\n * Get row from the table.\n * @param id Id of the row to retrieve, -1 returns the current new line.\n */\n  getRow(id: number): TableElement<T> {\n    const source = this.rowsSubject.getValue();\n    const index = this.getIndexFromRowId(id, source);\n\n    return (index >= 0 && index < source.length) ? source[index] : null;\n  }\n\n  /**\n   * Update the datasource with a new array of data. If the array reference\n   * is the same as the previous one, it doesn't trigger an update.\n   * @param data Data to update the table datasource.\n   * @param options Specify options to update the datasource.\n   * If emitEvent is true and the datasource is updated, it emits an event\n   * from 'datasourceSubject' with the updated data. If false, it doesn't\n   * emit an event. True by default.\n   */\n  updateDatasource(data: T[], options = { emitEvent: true }): void {\n    if (this.currentData !== data) {\n      this.currentData = data;\n      this.rowsSubject.next(this.getRowsFromData(data))\n\n      if (options.emitEvent)\n        this.datasourceSubject.next(data);\n    }\n  }\n\n\n  /**\n   * Checks the existance of the a new row (not yet saved).\n   * @param source\n   */\n  protected existsNewElement(source: TableElement<T>[]): boolean {\n      return !(source.length == 0 || source[this.getNewRowIndex(source)].id > -1)\n  }\n\n  /**\n   * Returns the possible index of the new row depending on the insertion type.\n   * It doesn't imply that the new row is created, that must be checked.\n   * @param source\n   */\n  protected getNewRowIndex(source): number {\n    if (this.config.prependNewElements)\n      return 0;\n    else\n      return source.length - 1;\n  }\n\n  /**\n   * Returns the row id from the index specified. It does\n   * not consider if the new row is present or not, assumes\n   * that new row is not present.\n   * @param index Index of the array.\n   * @param count Quantity of elements in the array.\n   */\n  protected getRowIdFromIndex(index: number, count: number): number {\n    if (this.config.prependNewElements)\n      return count - 1 - index;\n    else\n      return index;\n  }\n\n  /**\n   * Returns the index from the row id specified.\n   * It takes into account if the new row exists or not.\n   * @param id\n   * @param source\n   */\n  protected getIndexFromRowId(id: number, source: TableElement<T>[]): number {\n    if(id == -1) {\n      return this.existsNewElement(source) ? this.getNewRowIndex(source) : -1;\n    } else {\n      if (this.config.prependNewElements)\n          return source.length - 1 - id;\n      else\n        return id;\n    }\n  }\n\n  /**\n   * Update rows ids in the array specified, starting in the specified index\n   * until the start/end of the array, depending on config.prependNewElements\n   * configuration.\n   * @param initialIndex Initial index of source to be updated.\n   * @param source Array that contains the rows to be updated.\n   */\n  protected updateRowIds(initialIndex: number, source: TableElement<T>[]): void {\n\n    const delta = this.config.prependNewElements ? -1 : 1;\n\n    for (let index = initialIndex; index < source.length && index >= 0; index += delta) {\n      if (source[index].id != -1)\n        source[index].id = this.getRowIdFromIndex(index, source.length);\n    }\n  }\n\n  /**\n   * Get the data from the rows.\n   * @param rows Rows to extract the data.\n   */\n  protected getDataFromRows(rows: TableElement<T>[]): T[] {\n    return rows\n      .filter(row => row.id != -1)\n      .map<T>((row) => {\n      return row.originalData ? row.originalData : row.currentData;\n    });\n  }\n\n  /**\n   * Update the datasource with the data contained in the specified rows.\n   * @param rows Rows that contains the datasource's new data.\n   */\n  protected updateDatasourceFromRows(rows: TableElement<T>[]): void {\n    this.currentData = this.getDataFromRows(rows);\n    this.datasourceSubject.next(this.currentData);\n  }\n\n  /**\n   * From an array of data, it returns rows containing the original data.\n   * @param arrayData Data from which create the rows.\n   */\n  protected getRowsFromData(arrayData: T[]): TableElement<T>[] {\n    return arrayData.map<TableElement<T>>((data, index) => {\n\n      return TableElementFactory.createTableElement({\n        id: this.getRowIdFromIndex(index, arrayData.length),\n        editing: false,\n        currentData: data,\n        source: this,\n        validator: this.validatorService.getRowValidator(),\n      })\n    });\n  }\n\n  /**\n   * Create a new object with identical structure than the table source data.\n   * It uses the object's type contructor if available, otherwise it creates\n   * an object with the same keys of the first element contained in the original\n   * datasource (used in the constructor).\n   */\n  protected createNewObject(): T {\n    if (this.dataConstructor) {\n      return new this.dataConstructor();\n    } else {\n      return this.dataKeys.reduce((obj, key) => {\n        obj[key] = undefined;\n        return obj;\n      }, {});\n    }\n\n  }\n\n  /** Connect function called by the table to retrieve one stream containing\n   *  the data to render. */\n  /*connect(): Observable<TableElement<T>[]> {\n    return this.rowsSubject.asObservable();\n  }*/\n\n  connect(collectionViewer: CollectionViewer): Observable<TableElement<T>[] | ReadonlyArray<TableElement<T>>> {\n    const range: ListRange = {\n      start: 0,\n      end: -1\n    }\n    if (collectionViewer){\n      this.connectedViewers.push({\n        viewer: collectionViewer,\n        range,\n        subscription: collectionViewer.viewChange.subscribe(r => {\n          range.start = r.start;\n          range.end = r.end;\n        })\n      });\n    }\n    return this.rowsSubject.asObservable()\n      .pipe(\n        map(data => {\n          if (range.start > 0) {\n            if (range.end > range.start) {\n              return data.slice(range.start, range.end);\n            }\n            return data.slice(range.start);\n          }\n          return data;\n        })\n      );\n  }\n\n  disconnect(collectionViewer: CollectionViewer) {\n    const ref = this.connectedViewers.find(ref => ref.viewer === collectionViewer);\n    if (ref && ref.subscription) {\n      ref.subscription.unsubscribe();\n    }\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { FormGroup } from '@angular/forms';\n\n@Injectable()\nexport abstract class ValidatorService {\n  abstract getRowValidator(): FormGroup;\n}\n"]}