import { DataSource } from '@angular/cdk/collections';
import { BehaviorSubject, Subject } from 'rxjs';
import { TableElementFactory } from './table-element.factory';
import { DefaultValidatorService } from './default-validator.service';
import { map } from 'rxjs/operators';
export class TableDataSource extends DataSource {
    /**
     * Creates a new TableDataSource instance, that can be used as datasource of `@angular/cdk` data-table.
     * @param data Array containing the initial values for the TableDataSource. If not specified, then `dataType` must be specified.
     * @param dataType Type of data contained by the Table. If not specified, then `data` with at least one element must be specified.
     * @param validatorService Service that create instances of the FormGroup used to validate row fields.
     * @param config Additional configuration for table.
     */
    constructor(data, dataType, validatorService, config = { prependNewElements: false, suppressErrors: false }) {
        super();
        this.validatorService = validatorService;
        this.config = config;
        this.connectedViewers = [];
        if (!validatorService) {
            this.validatorService = new DefaultValidatorService();
        }
        if (dataType) {
            this.dataConstructor = dataType;
        }
        else {
            if (data && data.length > 0) {
                this.dataKeys = Object.keys(data[0]);
            }
            else {
                throw new Error('You must define either a non empty array, or an associated class to build the table.');
            }
        }
        this.checkValidatorFields(this.validatorService);
        this.rowsSubject = new BehaviorSubject(this.getRowsFromData(data));
        this.datasourceSubject = new Subject();
    }
    checkValidatorFields(validatorService) {
        if (!this.config.suppressErrors)
            return; // Skip, as error will not be logged
        const formGroup = validatorService.getRowValidator();
        if (formGroup != null) {
            const rowKeys = Object.keys(this.createNewObject());
            const invalidKeys = Object.keys(formGroup.controls).filter(key => !rowKeys.some(x => x === key));
            if (invalidKeys.length > 0) {
                this.logError('Validator form control keys must match row object keys. Invalid keys: ' + invalidKeys.toString());
            }
        }
    }
    logError(message) {
        if (!this.config.suppressErrors)
            console.error(message);
    }
    /**
     * Start the creation of a new element, pushing an empty-data row in the table.
     */
    createNew() {
        const source = this.rowsSubject.getValue();
        if (!this.existsNewElement(source)) {
            const newElement = TableElementFactory.createTableElement({
                id: -1,
                editing: true,
                currentData: this.createNewObject(),
                source: this,
                validator: this.validatorService.getRowValidator(),
            });
            if (this.config.prependNewElements) {
                this.rowsSubject.next([newElement].concat(source));
            }
            else {
                source.push(newElement);
                this.rowsSubject.next(source);
            }
        }
    }
    /**
     * Confirm creation of the row. Save changes and disable editing.
     * If validation active and row data is invalid, it doesn't confirm creation neither disable editing.
     * @param row Row to be confirmed.
     */
    confirmCreate(row) {
        if (!row.isValid()) {
            return false;
        }
        const source = this.rowsSubject.getValue();
        row.id = source.length - 1;
        this.rowsSubject.next(source);
        row.editing = false;
        this.updateDatasourceFromRows(source);
        return true;
    }
    /**
     * Confirm edition of the row. Save changes and disable editing.
     * If validation active and row data is invalid, it doesn't confirm editing neither disable editing.
     * @param row Row to be edited.
     */
    confirmEdit(row) {
        if (!row.isValid()) {
            return false;
        }
        const source = this.rowsSubject.getValue();
        const index = this.getIndexFromRowId(row.id, source);
        source[index] = row;
        this.rowsSubject.next(source);
        row.originalData = undefined;
        row.editing = false;
        this.updateDatasourceFromRows(source);
        return true;
    }
    /**
     * Delete the row with the index specified.
     */
    delete(id) {
        const source = this.rowsSubject.getValue();
        const index = this.getIndexFromRowId(id, source);
        source.splice(index, 1);
        this.updateRowIds(index, source);
        this.rowsSubject.next(source);
        if (id != -1)
            this.updateDatasourceFromRows(source);
    }
    /**
   * Get row from the table.
   * @param id Id of the row to retrieve, -1 returns the current new line.
   */
    getRow(id) {
        const source = this.rowsSubject.getValue();
        const index = this.getIndexFromRowId(id, source);
        return (index >= 0 && index < source.length) ? source[index] : null;
    }
    /**
     * Update the datasource with a new array of data. If the array reference
     * is the same as the previous one, it doesn't trigger an update.
     * @param data Data to update the table datasource.
     * @param options Specify options to update the datasource.
     * If emitEvent is true and the datasource is updated, it emits an event
     * from 'datasourceSubject' with the updated data. If false, it doesn't
     * emit an event. True by default.
     */
    updateDatasource(data, options = { emitEvent: true }) {
        if (this.currentData !== data) {
            this.currentData = data;
            this.rowsSubject.next(this.getRowsFromData(data));
            if (options.emitEvent)
                this.datasourceSubject.next(data);
        }
    }
    /**
     * Checks the existance of the a new row (not yet saved).
     * @param source
     */
    existsNewElement(source) {
        return !(source.length == 0 || source[this.getNewRowIndex(source)].id > -1);
    }
    /**
     * Returns the possible index of the new row depending on the insertion type.
     * It doesn't imply that the new row is created, that must be checked.
     * @param source
     */
    getNewRowIndex(source) {
        if (this.config.prependNewElements)
            return 0;
        else
            return source.length - 1;
    }
    /**
     * Returns the row id from the index specified. It does
     * not consider if the new row is present or not, assumes
     * that new row is not present.
     * @param index Index of the array.
     * @param count Quantity of elements in the array.
     */
    getRowIdFromIndex(index, count) {
        if (this.config.prependNewElements)
            return count - 1 - index;
        else
            return index;
    }
    /**
     * Returns the index from the row id specified.
     * It takes into account if the new row exists or not.
     * @param id
     * @param source
     */
    getIndexFromRowId(id, source) {
        if (id == -1) {
            return this.existsNewElement(source) ? this.getNewRowIndex(source) : -1;
        }
        else {
            if (this.config.prependNewElements)
                return source.length - 1 - id;
            else
                return id;
        }
    }
    /**
     * Update rows ids in the array specified, starting in the specified index
     * until the start/end of the array, depending on config.prependNewElements
     * configuration.
     * @param initialIndex Initial index of source to be updated.
     * @param source Array that contains the rows to be updated.
     */
    updateRowIds(initialIndex, source) {
        const delta = this.config.prependNewElements ? -1 : 1;
        for (let index = initialIndex; index < source.length && index >= 0; index += delta) {
            if (source[index].id != -1)
                source[index].id = this.getRowIdFromIndex(index, source.length);
        }
    }
    /**
     * Get the data from the rows.
     * @param rows Rows to extract the data.
     */
    getDataFromRows(rows) {
        return rows
            .filter(row => row.id != -1)
            .map((row) => {
            return row.originalData ? row.originalData : row.currentData;
        });
    }
    /**
     * Update the datasource with the data contained in the specified rows.
     * @param rows Rows that contains the datasource's new data.
     */
    updateDatasourceFromRows(rows) {
        this.currentData = this.getDataFromRows(rows);
        this.datasourceSubject.next(this.currentData);
    }
    /**
     * From an array of data, it returns rows containing the original data.
     * @param arrayData Data from which create the rows.
     */
    getRowsFromData(arrayData) {
        return arrayData.map((data, index) => {
            return TableElementFactory.createTableElement({
                id: this.getRowIdFromIndex(index, arrayData.length),
                editing: false,
                currentData: data,
                source: this,
                validator: this.validatorService.getRowValidator(),
            });
        });
    }
    /**
     * Create a new object with identical structure than the table source data.
     * It uses the object's type contructor if available, otherwise it creates
     * an object with the same keys of the first element contained in the original
     * datasource (used in the constructor).
     */
    createNewObject() {
        if (this.dataConstructor) {
            return new this.dataConstructor();
        }
        else {
            return this.dataKeys.reduce((obj, key) => {
                obj[key] = undefined;
                return obj;
            }, {});
        }
    }
    /** Connect function called by the table to retrieve one stream containing
     *  the data to render. */
    /*connect(): Observable<TableElement<T>[]> {
      return this.rowsSubject.asObservable();
    }*/
    connect(collectionViewer) {
        const range = {
            start: 0,
            end: -1
        };
        if (collectionViewer) {
            this.connectedViewers.push({
                viewer: collectionViewer,
                range,
                subscription: collectionViewer.viewChange.subscribe(r => {
                    range.start = r.start;
                    range.end = r.end;
                })
            });
        }
        return this.rowsSubject.asObservable()
            .pipe(map(data => {
            if (range.start > 0) {
                if (range.end > range.start) {
                    return data.slice(range.start, range.end);
                }
                return data.slice(range.start);
            }
            return data;
        }));
    }
    disconnect(collectionViewer) {
        const ref = this.connectedViewers.find(ref => ref.viewer === collectionViewer);
        if (ref && ref.subscription) {
            ref.subscription.unsubscribe();
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUtZGF0YS1zb3VyY2UuanMiLCJzb3VyY2VSb290IjoiLi4vLi4vIiwic291cmNlcyI6WyJzcmMvYXBwL25neC1tYXRlcmlhbC10YWJsZS90YWJsZS1kYXRhLXNvdXJjZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQW1CLFVBQVUsRUFBWSxNQUFNLDBCQUEwQixDQUFDO0FBRWpGLE9BQU8sRUFBQyxlQUFlLEVBQWMsT0FBTyxFQUE2QixNQUFNLE1BQU0sQ0FBQztBQUV0RixPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUc5RCxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUN0RSxPQUFPLEVBQUMsR0FBRyxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFFbkMsTUFBTSxPQUFPLGVBQW1CLFNBQVEsVUFBMkI7SUFlakU7Ozs7OztPQU1HO0lBQ0gsWUFDRSxJQUFTLEVBQ1QsUUFBc0IsRUFDZCxnQkFBbUMsRUFDbkMsU0FBUyxFQUFFLGtCQUFrQixFQUFFLEtBQUssRUFBRSxjQUFjLEVBQUUsS0FBSyxFQUFFO1FBQ3JFLEtBQUssRUFBRSxDQUFDO1FBRkEscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFtQjtRQUNuQyxXQUFNLEdBQU4sTUFBTSxDQUF1RDtRQW5CN0QscUJBQWdCLEdBSXBCLEVBQUUsQ0FBQztRQWtCUCxJQUFJLENBQUMsZ0JBQWdCLEVBQUU7WUFDckIsSUFBSSxDQUFDLGdCQUFnQixHQUFHLElBQUksdUJBQXVCLEVBQUUsQ0FBQztTQUN2RDtRQUVELElBQUksUUFBUSxFQUFFO1lBQ1osSUFBSSxDQUFDLGVBQWUsR0FBRyxRQUFRLENBQUM7U0FDakM7YUFBTTtZQUNMLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQUMzQixJQUFJLENBQUMsUUFBUSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxD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QUFPLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7aUJBQzNDO2dCQUNELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDaEM7WUFDRCxPQUFPLElBQUksQ0FBQztRQUNkLENBQUMsQ0FBQyxDQUNILENBQUM7SUFDTixDQUFDO0lBRUQsVUFBVSxDQUFDLGdCQUFrQztRQUMzQyxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLE1BQU0sS0FBSyxnQkFBZ0IsQ0FBQyxDQUFDO1FBQy9FLElBQUksR0FBRyxJQUFJLEdBQUcsQ0FBQyxZQUFZLEVBQUU7WUFDM0IsR0FBRyxDQUFDLFlBQVksQ0FBQyxXQUFXLEVBQUUsQ0FBQztTQUNoQztJQUNILENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Q29sbGVjdGlvblZpZXdlciwgRGF0YVNvdXJjZSwgTGlzdFJhbmdlfSBmcm9tICdAYW5ndWxhci9jZGsvY29sbGVjdGlvbnMnO1xuXG5pbXBvcnQge0JlaGF2aW9yU3ViamVjdCwgT2JzZXJ2YWJsZSwgU3ViamVjdCwgU3Vic2NyaWJhYmxlLCBTdWJzY3JpcHRpb259IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBUYWJsZUVsZW1lbnRGYWN0b3J5IH0gZnJvbSAnLi90YWJsZS1lbGVtZW50LmZhY3RvcnknO1xuaW1wb3J0IHsgVmFsaWRhdG9yU2VydmljZSB9IGZyb20gJy4vdmFsaWRhdG9yLnNlcnZpY2UnO1xuaW1wb3J0IHsgVGFibGVFbGVtZW50IH0gZnJvbSAnLi90YWJsZS1lbGVtZW50JztcbmltcG9ydCB7IERlZmF1bHRWYWxpZGF0b3JTZXJ2aWNlIH0gZnJvbSAnLi9kZWZhdWx0LXZhbGlkYXRvci5zZXJ2aWNlJztcbmltcG9ydCB7bWFwfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmV4cG9ydCBjbGFzcyBUYWJsZURhdGFTb3VyY2U8VD4gZXh0ZW5kcyBEYXRhU291cmNlPFRhYmxlRWxlbWVudDxUPj4ge1xuXG4gIHByb3RlY3RlZCByb3dzU3ViamVjdDogQmVoYXZpb3JTdWJqZWN0PFRhYmxlRWxlbWVudDxUPltdPjtcbiAgZGF0YXNvdXJjZVN1YmplY3Q6IFN1YmplY3Q8VFtdPjtcblxuICBwcm90ZWN0ZWQgZGF0YUNvbnN0cnVjdG9yOiBuZXcgKCkgPT4gVDtcbiAgcHJvdGVjdGVkIGRhdGFLZXlzOiBhbnlbXTtcbiAgcHJvdGVjdGVkIGNvbm5lY3RlZFZpZXdlcnM6IHtcbiAgICB2aWV3ZXI6IENvbGxlY3Rpb25WaWV3ZXI7XG4gICAgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gICAgcmFuZ2U6IExpc3RSYW5nZTtcbiAgfVtdID0gW107XG5cbiAgcHJvdGVjdGVkIGN1cnJlbnREYXRhOiBhbnk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgVGFibGVEYXRhU291cmNlIGluc3RhbmNlLCB0aGF0IGNhbiBiZSB1c2VkIGFzIGRhdGFzb3VyY2Ugb2YgYEBhbmd1bGFyL2Nka2AgZGF0YS10YWJsZS5cbiAgICogQHBhcmFtIGRhdGEgQXJyYXkgY29udGFpbmluZyB0aGUgaW5pdGlhbCB2YWx1ZXMgZm9yIHRoZSBUYWJsZURhdGFTb3VyY2UuIElmIG5vdCBzcGVjaWZpZWQsIHRoZW4gYGRhdGFUeXBlYCBtdXN0IGJlIHNwZWNpZmllZC5cbiAgICogQHBhcmFtIGRhdGFUeXBlIFR5cGUgb2YgZGF0YSBjb250YWluZWQgYnkgdGhlIFRhYmxlLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGVuIGBkYXRhYCB3aXRoIGF0IGxlYXN0IG9uZSBlbGVtZW50IG11c3QgYmUgc3BlY2lmaWVkLlxuICAgKiBAcGFyYW0gdmFsaWRhdG9yU2VydmljZSBTZXJ2aWNlIHRoYXQgY3JlYXRlIGluc3RhbmNlcyBvZiB0aGUgRm9ybUdyb3VwIHVzZWQgdG8gdmFsaWRhdGUgcm93IGZpZWxkcy5cbiAgICogQHBhcmFtIGNvbmZpZyBBZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24gZm9yIHRhYmxlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgZGF0YTogVFtdLFxuICAgIGRhdGFUeXBlPzogbmV3ICgpID0+IFQsXG4gICAgcHJpdmF0ZSB2YWxpZGF0b3JTZXJ2aWNlPzogVmFsaWRhdG9yU2VydmljZSxcbiAgICBwcml2YXRlIGNvbmZpZyA9IHsgcHJlcGVuZE5ld0VsZW1lbnRzOiBmYWxzZSwgc3VwcHJlc3NFcnJvcnM6IGZhbHNlIH0pIHtcbiAgICBzdXBlcigpO1xuXG4gICAgaWYgKCF2YWxpZGF0b3JTZXJ2aWNlKSB7XG4gICAgICB0aGlzLnZhbGlkYXRvclNlcnZpY2UgPSBuZXcgRGVmYXVsdFZhbGlkYXRvclNlcnZpY2UoKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YVR5cGUpIHtcbiAgICAgIHRoaXMuZGF0YUNvbnN0cnVjdG9yID0gZGF0YVR5cGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkYXRhICYmIGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmRhdGFLZXlzID0gT2JqZWN0LmtleXMoZGF0YVswXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IGRlZmluZSBlaXRoZXIgYSBub24gZW1wdHkgYXJyYXksIG9yIGFuIGFzc29jaWF0ZWQgY2xhc3MgdG8gYnVpbGQgdGhlIHRhYmxlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY2hlY2tWYWxpZGF0b3JGaWVsZHModGhpcy52YWxpZGF0b3JTZXJ2aWNlKTtcblxuICAgIHRoaXMucm93c1N1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHRoaXMuZ2V0Um93c0Zyb21EYXRhKGRhdGEpKTtcbiAgICB0aGlzLmRhdGFzb3VyY2VTdWJqZWN0ID0gbmV3IFN1YmplY3Q8VFtdPigpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGNoZWNrVmFsaWRhdG9yRmllbGRzKHZhbGlkYXRvclNlcnZpY2U6IFZhbGlkYXRvclNlcnZpY2UpIHtcbiAgICBpZiAoIXRoaXMuY29uZmlnLnN1cHByZXNzRXJyb3JzKSByZXR1cm47IC8vIFNraXAsIGFzIGVycm9yIHdpbGwgbm90IGJlIGxvZ2dlZFxuICAgIGNvbnN0IGZvcm1Hcm91cCA9IHZhbGlkYXRvclNlcnZpY2UuZ2V0Um93VmFsaWRhdG9yKCk7XG4gICAgaWYoZm9ybUdyb3VwICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHJvd0tleXMgPSBPYmplY3Qua2V5cyh0aGlzLmNyZWF0ZU5ld09iamVjdCgpKTtcbiAgICAgIGNvbnN0IGludmFsaWRLZXlzID0gT2JqZWN0LmtleXMoZm9ybUdyb3VwLmNvbnRyb2xzKS5maWx0ZXIoa2V5ID0+ICFyb3dLZXlzLnNvbWUoeCA9PiB4ID09PSBrZXkpKTtcbiAgICAgIGlmIChpbnZhbGlkS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMubG9nRXJyb3IoJ1ZhbGlkYXRvciBmb3JtIGNvbnRyb2wga2V5cyBtdXN0IG1hdGNoIHJvdyBvYmplY3Qga2V5cy4gSW52YWxpZCBrZXlzOiAnICsgaW52YWxpZEtleXMudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGxvZ0Vycm9yKG1lc3NhZ2U6IHN0cmluZykge1xuICAgIGlmKCF0aGlzLmNvbmZpZy5zdXBwcmVzc0Vycm9ycylcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgdGhlIGNyZWF0aW9uIG9mIGEgbmV3IGVsZW1lbnQsIHB1c2hpbmcgYW4gZW1wdHktZGF0YSByb3cgaW4gdGhlIHRhYmxlLlxuICAgKi9cbiAgY3JlYXRlTmV3KCk6IHZvaWQge1xuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMucm93c1N1YmplY3QuZ2V0VmFsdWUoKTtcblxuICAgIGlmICghdGhpcy5leGlzdHNOZXdFbGVtZW50KHNvdXJjZSkpIHtcblxuICAgICAgY29uc3QgbmV3RWxlbWVudCA9IFRhYmxlRWxlbWVudEZhY3RvcnkuY3JlYXRlVGFibGVFbGVtZW50KHtcbiAgICAgICAgaWQ6IC0xLFxuICAgICAgICBlZGl0aW5nOiB0cnVlLFxuICAgICAgICBjdXJyZW50RGF0YTogdGhpcy5jcmVhdGVOZXdPYmplY3QoKSxcbiAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICB2YWxpZGF0b3I6IHRoaXMudmFsaWRhdG9yU2VydmljZS5nZXRSb3dWYWxpZGF0b3IoKSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5jb25maWcucHJlcGVuZE5ld0VsZW1lbnRzKSB7XG4gICAgICAgIHRoaXMucm93c1N1YmplY3QubmV4dChbbmV3RWxlbWVudF0uY29uY2F0KHNvdXJjZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc291cmNlLnB1c2gobmV3RWxlbWVudCk7XG4gICAgICAgIHRoaXMucm93c1N1YmplY3QubmV4dChzb3VyY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25maXJtIGNyZWF0aW9uIG9mIHRoZSByb3cuIFNhdmUgY2hhbmdlcyBhbmQgZGlzYWJsZSBlZGl0aW5nLlxuICAgKiBJZiB2YWxpZGF0aW9uIGFjdGl2ZSBhbmQgcm93IGRhdGEgaXMgaW52YWxpZCwgaXQgZG9lc24ndCBjb25maXJtIGNyZWF0aW9uIG5laXRoZXIgZGlzYWJsZSBlZGl0aW5nLlxuICAgKiBAcGFyYW0gcm93IFJvdyB0byBiZSBjb25maXJtZWQuXG4gICAqL1xuICBjb25maXJtQ3JlYXRlKHJvdzogVGFibGVFbGVtZW50PFQ+KTogYm9vbGVhbiB7XG4gICAgaWYgKCFyb3cuaXNWYWxpZCgpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnJvd3NTdWJqZWN0LmdldFZhbHVlKCk7XG4gICAgcm93LmlkID0gc291cmNlLmxlbmd0aCAtIDE7XG4gICAgdGhpcy5yb3dzU3ViamVjdC5uZXh0KHNvdXJjZSk7XG5cbiAgICByb3cuZWRpdGluZyA9IGZhbHNlO1xuXG4gICAgdGhpcy51cGRhdGVEYXRhc291cmNlRnJvbVJvd3Moc291cmNlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25maXJtIGVkaXRpb24gb2YgdGhlIHJvdy4gU2F2ZSBjaGFuZ2VzIGFuZCBkaXNhYmxlIGVkaXRpbmcuXG4gICAqIElmIHZhbGlkYXRpb24gYWN0aXZlIGFuZCByb3cgZGF0YSBpcyBpbnZhbGlkLCBpdCBkb2Vzbid0IGNvbmZpcm0gZWRpdGluZyBuZWl0aGVyIGRpc2FibGUgZWRpdGluZy5cbiAgICogQHBhcmFtIHJvdyBSb3cgdG8gYmUgZWRpdGVkLlxuICAgKi9cbiAgY29uZmlybUVkaXQocm93OiBUYWJsZUVsZW1lbnQ8VD4pOiBib29sZWFuIHtcbiAgICBpZiAoIXJvdy5pc1ZhbGlkKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnJvd3NTdWJqZWN0LmdldFZhbHVlKCk7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmdldEluZGV4RnJvbVJvd0lkKHJvdy5pZCwgc291cmNlKTtcblxuICAgIHNvdXJjZVtpbmRleF0gPSByb3c7XG4gICAgdGhpcy5yb3dzU3ViamVjdC5uZXh0KHNvdXJjZSk7XG5cbiAgICByb3cub3JpZ2luYWxEYXRhID0gdW5kZWZpbmVkO1xuICAgIHJvdy5lZGl0aW5nID0gZmFsc2U7XG5cbiAgICB0aGlzLnVwZGF0ZURhdGFzb3VyY2VGcm9tUm93cyhzb3VyY2UpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSB0aGUgcm93IHdpdGggdGhlIGluZGV4IHNwZWNpZmllZC5cbiAgICovXG4gIGRlbGV0ZShpZDogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5yb3dzU3ViamVjdC5nZXRWYWx1ZSgpO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5nZXRJbmRleEZyb21Sb3dJZChpZCwgc291cmNlKTtcblxuICAgIHNvdXJjZS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHRoaXMudXBkYXRlUm93SWRzKGluZGV4LCBzb3VyY2UpO1xuXG4gICAgdGhpcy5yb3dzU3ViamVjdC5uZXh0KHNvdXJjZSk7XG5cbiAgICBpZiAoaWQgIT0gLTEpXG4gICAgICB0aGlzLnVwZGF0ZURhdGFzb3VyY2VGcm9tUm93cyhzb3VyY2UpO1xuICB9XG5cbiAgLyoqXG4gKiBHZXQgcm93IGZyb20gdGhlIHRhYmxlLlxuICogQHBhcmFtIGlkIElkIG9mIHRoZSByb3cgdG8gcmV0cmlldmUsIC0xIHJldHVybnMgdGhlIGN1cnJlbnQgbmV3IGxpbmUuXG4gKi9cbiAgZ2V0Um93KGlkOiBudW1iZXIpOiBUYWJsZUVsZW1lbnQ8VD4ge1xuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMucm93c1N1YmplY3QuZ2V0VmFsdWUoKTtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0SW5kZXhGcm9tUm93SWQoaWQsIHNvdXJjZSk7XG5cbiAgICByZXR1cm4gKGluZGV4ID49IDAgJiYgaW5kZXggPCBzb3VyY2UubGVuZ3RoKSA/IHNvdXJjZVtpbmRleF0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgZGF0YXNvdXJjZSB3aXRoIGEgbmV3IGFycmF5IG9mIGRhdGEuIElmIHRoZSBhcnJheSByZWZlcmVuY2VcbiAgICogaXMgdGhlIHNhbWUgYXMgdGhlIHByZXZpb3VzIG9uZSwgaXQgZG9lc24ndCB0cmlnZ2VyIGFuIHVwZGF0ZS5cbiAgICogQHBhcmFtIGRhdGEgRGF0YSB0byB1cGRhdGUgdGhlIHRhYmxlIGRhdGFzb3VyY2UuXG4gICAqIEBwYXJhbSBvcHRpb25zIFNwZWNpZnkgb3B0aW9ucyB0byB1cGRhdGUgdGhlIGRhdGFzb3VyY2UuXG4gICAqIElmIGVtaXRFdmVudCBpcyB0cnVlIGFuZCB0aGUgZGF0YXNvdXJjZSBpcyB1cGRhdGVkLCBpdCBlbWl0cyBhbiBldmVudFxuICAgKiBmcm9tICdkYXRhc291cmNlU3ViamVjdCcgd2l0aCB0aGUgdXBkYXRlZCBkYXRhLiBJZiBmYWxzZSwgaXQgZG9lc24ndFxuICAgKiBlbWl0IGFuIGV2ZW50LiBUcnVlIGJ5IGRlZmF1bHQuXG4gICAqL1xuICB1cGRhdGVEYXRhc291cmNlKGRhdGE6IFRbXSwgb3B0aW9ucyA9IHsgZW1pdEV2ZW50OiB0cnVlIH0pOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jdXJyZW50RGF0YSAhPT0gZGF0YSkge1xuICAgICAgdGhpcy5jdXJyZW50RGF0YSA9IGRhdGE7XG4gICAgICB0aGlzLnJvd3NTdWJqZWN0Lm5leHQodGhpcy5nZXRSb3dzRnJvbURhdGEoZGF0YSkpXG5cbiAgICAgIGlmIChvcHRpb25zLmVtaXRFdmVudClcbiAgICAgICAgdGhpcy5kYXRhc291cmNlU3ViamVjdC5uZXh0KGRhdGEpO1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIENoZWNrcyB0aGUgZXhpc3RhbmNlIG9mIHRoZSBhIG5ldyByb3cgKG5vdCB5ZXQgc2F2ZWQpLlxuICAgKiBAcGFyYW0gc291cmNlXG4gICAqL1xuICBwcm90ZWN0ZWQgZXhpc3RzTmV3RWxlbWVudChzb3VyY2U6IFRhYmxlRWxlbWVudDxUPltdKTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gIShzb3VyY2UubGVuZ3RoID09IDAgfHwgc291cmNlW3RoaXMuZ2V0TmV3Um93SW5kZXgoc291cmNlKV0uaWQgPiAtMSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwb3NzaWJsZSBpbmRleCBvZiB0aGUgbmV3IHJvdyBkZXBlbmRpbmcgb24gdGhlIGluc2VydGlvbiB0eXBlLlxuICAgKiBJdCBkb2Vzbid0IGltcGx5IHRoYXQgdGhlIG5ldyByb3cgaXMgY3JlYXRlZCwgdGhhdCBtdXN0IGJlIGNoZWNrZWQuXG4gICAqIEBwYXJhbSBzb3VyY2VcbiAgICovXG4gIHByb3RlY3RlZCBnZXROZXdSb3dJbmRleChzb3VyY2UpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLmNvbmZpZy5wcmVwZW5kTmV3RWxlbWVudHMpXG4gICAgICByZXR1cm4gMDtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gc291cmNlLmxlbmd0aCAtIDE7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcm93IGlkIGZyb20gdGhlIGluZGV4IHNwZWNpZmllZC4gSXQgZG9lc1xuICAgKiBub3QgY29uc2lkZXIgaWYgdGhlIG5ldyByb3cgaXMgcHJlc2VudCBvciBub3QsIGFzc3VtZXNcbiAgICogdGhhdCBuZXcgcm93IGlzIG5vdCBwcmVzZW50LlxuICAgKiBAcGFyYW0gaW5kZXggSW5kZXggb2YgdGhlIGFycmF5LlxuICAgKiBAcGFyYW0gY291bnQgUXVhbnRpdHkgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5LlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFJvd0lkRnJvbUluZGV4KGluZGV4OiBudW1iZXIsIGNvdW50OiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLmNvbmZpZy5wcmVwZW5kTmV3RWxlbWVudHMpXG4gICAgICByZXR1cm4gY291bnQgLSAxIC0gaW5kZXg7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluZGV4IGZyb20gdGhlIHJvdyBpZCBzcGVjaWZpZWQuXG4gICAqIEl0IHRha2VzIGludG8gYWNjb3VudCBpZiB0aGUgbmV3IHJvdyBleGlzdHMgb3Igbm90LlxuICAgKiBAcGFyYW0gaWRcbiAgICogQHBhcmFtIHNvdXJjZVxuICAgKi9cbiAgcHJvdGVjdGVkIGdldEluZGV4RnJvbVJvd0lkKGlkOiBudW1iZXIsIHNvdXJjZTogVGFibGVFbGVtZW50PFQ+W10pOiBudW1iZXIge1xuICAgIGlmKGlkID09IC0xKSB7XG4gICAgICByZXR1cm4gdGhpcy5leGlzdHNOZXdFbGVtZW50KHNvdXJjZSkgPyB0aGlzLmdldE5ld1Jvd0luZGV4KHNvdXJjZSkgOiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuY29uZmlnLnByZXBlbmROZXdFbGVtZW50cylcbiAgICAgICAgICByZXR1cm4gc291cmNlLmxlbmd0aCAtIDEgLSBpZDtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgcm93cyBpZHMgaW4gdGhlIGFycmF5IHNwZWNpZmllZCwgc3RhcnRpbmcgaW4gdGhlIHNwZWNpZmllZCBpbmRleFxuICAgKiB1bnRpbCB0aGUgc3RhcnQvZW5kIG9mIHRoZSBhcnJheSwgZGVwZW5kaW5nIG9uIGNvbmZpZy5wcmVwZW5kTmV3RWxlbWVudHNcbiAgICogY29uZmlndXJhdGlvbi5cbiAgICogQHBhcmFtIGluaXRpYWxJbmRleCBJbml0aWFsIGluZGV4IG9mIHNvdXJjZSB0byBiZSB1cGRhdGVkLlxuICAgKiBAcGFyYW0gc291cmNlIEFycmF5IHRoYXQgY29udGFpbnMgdGhlIHJvd3MgdG8gYmUgdXBkYXRlZC5cbiAgICovXG4gIHByb3RlY3RlZCB1cGRhdGVSb3dJZHMoaW5pdGlhbEluZGV4OiBudW1iZXIsIHNvdXJjZTogVGFibGVFbGVtZW50PFQ+W10pOiB2b2lkIHtcblxuICAgIGNvbnN0IGRlbHRhID0gdGhpcy5jb25maWcucHJlcGVuZE5ld0VsZW1lbnRzID8gLTEgOiAxO1xuXG4gICAgZm9yIChsZXQgaW5kZXggPSBpbml0aWFsSW5kZXg7IGluZGV4IDwgc291cmNlLmxlbmd0aCAmJiBpbmRleCA+PSAwOyBpbmRleCArPSBkZWx0YSkge1xuICAgICAgaWYgKHNvdXJjZVtpbmRleF0uaWQgIT0gLTEpXG4gICAgICAgIHNvdXJjZVtpbmRleF0uaWQgPSB0aGlzLmdldFJvd0lkRnJvbUluZGV4KGluZGV4LCBzb3VyY2UubGVuZ3RoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkYXRhIGZyb20gdGhlIHJvd3MuXG4gICAqIEBwYXJhbSByb3dzIFJvd3MgdG8gZXh0cmFjdCB0aGUgZGF0YS5cbiAgICovXG4gIHByb3RlY3RlZCBnZXREYXRhRnJvbVJvd3Mocm93czogVGFibGVFbGVtZW50PFQ+W10pOiBUW10ge1xuICAgIHJldHVybiByb3dzXG4gICAgICAuZmlsdGVyKHJvdyA9PiByb3cuaWQgIT0gLTEpXG4gICAgICAubWFwPFQ+KChyb3cpID0+IHtcbiAgICAgIHJldHVybiByb3cub3JpZ2luYWxEYXRhID8gcm93Lm9yaWdpbmFsRGF0YSA6IHJvdy5jdXJyZW50RGF0YTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGRhdGFzb3VyY2Ugd2l0aCB0aGUgZGF0YSBjb250YWluZWQgaW4gdGhlIHNwZWNpZmllZCByb3dzLlxuICAgKiBAcGFyYW0gcm93cyBSb3dzIHRoYXQgY29udGFpbnMgdGhlIGRhdGFzb3VyY2UncyBuZXcgZGF0YS5cbiAgICovXG4gIHByb3RlY3RlZCB1cGRhdGVEYXRhc291cmNlRnJvbVJvd3Mocm93czogVGFibGVFbGVtZW50PFQ+W10pOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnREYXRhID0gdGhpcy5nZXREYXRhRnJvbVJvd3Mocm93cyk7XG4gICAgdGhpcy5kYXRhc291cmNlU3ViamVjdC5uZXh0KHRoaXMuY3VycmVudERhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZyb20gYW4gYXJyYXkgb2YgZGF0YSwgaXQgcmV0dXJucyByb3dzIGNvbnRhaW5pbmcgdGhlIG9yaWdpbmFsIGRhdGEuXG4gICAqIEBwYXJhbSBhcnJheURhdGEgRGF0YSBmcm9tIHdoaWNoIGNyZWF0ZSB0aGUgcm93cy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRSb3dzRnJvbURhdGEoYXJyYXlEYXRhOiBUW10pOiBUYWJsZUVsZW1lbnQ8VD5bXSB7XG4gICAgcmV0dXJuIGFycmF5RGF0YS5tYXA8VGFibGVFbGVtZW50PFQ+PigoZGF0YSwgaW5kZXgpID0+IHtcblxuICAgICAgcmV0dXJuIFRhYmxlRWxlbWVudEZhY3RvcnkuY3JlYXRlVGFibGVFbGVtZW50KHtcbiAgICAgICAgaWQ6IHRoaXMuZ2V0Um93SWRGcm9tSW5kZXgoaW5kZXgsIGFycmF5RGF0YS5sZW5ndGgpLFxuICAgICAgICBlZGl0aW5nOiBmYWxzZSxcbiAgICAgICAgY3VycmVudERhdGE6IGRhdGEsXG4gICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgdmFsaWRhdG9yOiB0aGlzLnZhbGlkYXRvclNlcnZpY2UuZ2V0Um93VmFsaWRhdG9yKCksXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBvYmplY3Qgd2l0aCBpZGVudGljYWwgc3RydWN0dXJlIHRoYW4gdGhlIHRhYmxlIHNvdXJjZSBkYXRhLlxuICAgKiBJdCB1c2VzIHRoZSBvYmplY3QncyB0eXBlIGNvbnRydWN0b3IgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgaXQgY3JlYXRlc1xuICAgKiBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIG9mIHRoZSBmaXJzdCBlbGVtZW50IGNvbnRhaW5lZCBpbiB0aGUgb3JpZ2luYWxcbiAgICogZGF0YXNvdXJjZSAodXNlZCBpbiB0aGUgY29uc3RydWN0b3IpLlxuICAgKi9cbiAgcHJvdGVjdGVkIGNyZWF0ZU5ld09iamVjdCgpOiBUIHtcbiAgICBpZiAodGhpcy5kYXRhQ29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5kYXRhQ29uc3RydWN0b3IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YUtleXMucmVkdWNlKChvYmosIGtleSkgPT4ge1xuICAgICAgICBvYmpba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH0sIHt9KTtcbiAgICB9XG5cbiAgfVxuXG4gIC8qKiBDb25uZWN0IGZ1bmN0aW9uIGNhbGxlZCBieSB0aGUgdGFibGUgdG8gcmV0cmlldmUgb25lIHN0cmVhbSBjb250YWluaW5nXG4gICAqICB0aGUgZGF0YSB0byByZW5kZXIuICovXG4gIC8qY29ubmVjdCgpOiBPYnNlcnZhYmxlPFRhYmxlRWxlbWVudDxUPltdPiB7XG4gICAgcmV0dXJuIHRoaXMucm93c1N1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gIH0qL1xuXG4gIGNvbm5lY3QoY29sbGVjdGlvblZpZXdlcjogQ29sbGVjdGlvblZpZXdlcik6IE9ic2VydmFibGU8VGFibGVFbGVtZW50PFQ+W10gfCBSZWFkb25seUFycmF5PFRhYmxlRWxlbWVudDxUPj4+IHtcbiAgICBjb25zdCByYW5nZTogTGlzdFJhbmdlID0ge1xuICAgICAgc3RhcnQ6IDAsXG4gICAgICBlbmQ6IC0xXG4gICAgfVxuICAgIGlmIChjb2xsZWN0aW9uVmlld2VyKXtcbiAgICAgIHRoaXMuY29ubmVjdGVkVmlld2Vycy5wdXNoKHtcbiAgICAgICAgdmlld2VyOiBjb2xsZWN0aW9uVmlld2VyLFxuICAgICAgICByYW5nZSxcbiAgICAgICAgc3Vic2NyaXB0aW9uOiBjb2xsZWN0aW9uVmlld2VyLnZpZXdDaGFuZ2Uuc3Vic2NyaWJlKHIgPT4ge1xuICAgICAgICAgIHJhbmdlLnN0YXJ0ID0gci5zdGFydDtcbiAgICAgICAgICByYW5nZS5lbmQgPSByLmVuZDtcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yb3dzU3ViamVjdC5hc09ic2VydmFibGUoKVxuICAgICAgLnBpcGUoXG4gICAgICAgIG1hcChkYXRhID0+IHtcbiAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnQgPiAwKSB7XG4gICAgICAgICAgICBpZiAocmFuZ2UuZW5kID4gcmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuc2xpY2UocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5zbGljZShyYW5nZS5zdGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3QoY29sbGVjdGlvblZpZXdlcjogQ29sbGVjdGlvblZpZXdlcikge1xuICAgIGNvbnN0IHJlZiA9IHRoaXMuY29ubmVjdGVkVmlld2Vycy5maW5kKHJlZiA9PiByZWYudmlld2VyID09PSBjb2xsZWN0aW9uVmlld2VyKTtcbiAgICBpZiAocmVmICYmIHJlZi5zdWJzY3JpcHRpb24pIHtcbiAgICAgIHJlZi5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==